# Convex Backend Guide for finlit.gg

> **Comprehensive guide covering Convex backend implementation for the finlit.gg MVP, including schema design, queries, mutations, authentication, real-time updates, scheduling, and integrations.**

## Table of Contents

1. [Overview](#overview)
2. [Project Structure](#project-structure)
3. [Schema Definition](#schema-definition)
4. [Queries & Mutations](#queries--mutations)
5. [Actions](#actions)
6. [Authentication with Better Auth](#authentication-with-better-auth)
7. [Real-time Subscriptions](#real-time-subscriptions)
8. [Scheduling & Cron Jobs](#scheduling--cron-jobs)
9. [File Storage](#file-storage)
10. [Notifications System](#notifications-system)
11. [Email Integration with Resend](#email-integration-with-resend)
12. [Testing Strategy](#testing-strategy)
13. [Best Practices](#best-practices)
14. [Common Patterns](#common-patterns)

---

## Overview

Convex is the reactive backend for finlit.gg, providing:

- **Reactive Database**: TypeScript queries that run in the database
- **Real-time Sync**: Live updates across all connected clients
- **Type Safety**: End-to-end TypeScript with generated types
- **Transactional**: ACID guarantees for all mutations
- **Built-in Features**: Auth, storage, scheduling, and more

### Why Convex for finlit.gg?

1. **Real-time approvals**: Guardian approval requests update instantly for kids
2. **Live notifications**: Toasts and badges update without polling
3. **Transactional integrity**: Money movements are ACID-compliant
4. **Type safety**: Data models flow from backend to frontend
5. **Simplified backend**: No need for separate API, database, and scheduler

---

## Project Structure

```
finlit.gg/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ convex/
â”‚   â”‚   â”œâ”€â”€ _generated/        # Auto-generated by Convex
â”‚   â”‚   â”œâ”€â”€ schema.ts           # Database schema
â”‚   â”‚   â”œâ”€â”€ auth.config.ts      # Better Auth configuration
â”‚   â”‚   â”œâ”€â”€ http.ts             # HTTP routes (webhooks, Better Auth)
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ households/         # Domain-organized functions
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â””â”€â”€ mutations.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ accounts/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â””â”€â”€ mutations.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ earn/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ mutations.ts
â”‚   â”‚   â”‚   â””â”€â”€ actions.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ goals/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â””â”€â”€ mutations.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ automations/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ mutations.ts
â”‚   â”‚   â”‚   â””â”€â”€ engine.ts       # Rules evaluation engine
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ notifications/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â”œâ”€â”€ mutations.ts
â”‚   â”‚   â”‚   â””â”€â”€ actions.ts      # Event processing
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ learn/
â”‚   â”‚   â”‚   â”œâ”€â”€ queries.ts
â”‚   â”‚   â”‚   â””â”€â”€ mutations.ts
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ crons.ts            # Scheduled functions
â”‚   â”‚
â”‚   â”œâ”€â”€ convex.json
â”‚   â””â”€â”€ package.json
â”‚
â”œâ”€â”€ apps/web/                    # Web app consumes Convex
â””â”€â”€ apps/mobile/                 # Mobile app consumes Convex
```

---

## Schema Definition

### Core Principles

1. **Use `defineSchema`**: Type-safe schema definition
2. **Index strategically**: Index fields used in queries
3. **Use `v` validators**: Ensure data integrity
4. **Plan for queries**: Design tables for read patterns

### Base Schema Structure

```typescript
// backend/convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";

export default defineSchema({
  // Identity & Access
  households: defineTable({
    name: v.string(),
    inviteCode: v.optional(v.string()),
    timezone: v.string(),
  }).index("by_invite_code", ["inviteCode"]),

  users: defineTable({
    householdId: v.id("households"),
    email: v.optional(v.string()),
    globalRole: v.union(v.literal("guardian"), v.literal("kid")),
    status: v.union(
      v.literal("active"),
      v.literal("invited"),
      v.literal("disabled")
    ),
    lastLoginAt: v.optional(v.number()),
  })
    .index("by_household", ["householdId"])
    .index("by_email", ["email"]),

  profiles: defineTable({
    userId: v.id("users"),
    displayName: v.string(),
    avatarUrl: v.optional(v.string()),
    dateOfBirth: v.optional(v.number()),
    pronouns: v.optional(v.string()),
    xpLevel: v.number(),
    featureFlags: v.optional(v.object({})),
  }).index("by_user", ["userId"]),

  guardianChildSettings: defineTable({
    guardianId: v.id("users"),
    kidId: v.id("users"),
    permissions: v.optional(v.object({})),
    notificationPrefs: v.optional(v.object({})),
  })
    .index("by_guardian", ["guardianId"])
    .index("by_kid", ["kidId"])
    .index("by_guardian_and_kid", ["guardianId", "kidId"]),

  // Financial Core
  accounts: defineTable({
    householdId: v.id("households"),
    ownerUserId: v.optional(v.id("users")),
    type: v.union(
      v.literal("save"),
      v.literal("invest"),
      v.literal("spend"),
      v.literal("donate"),
      v.literal("credit_collateral")
    ),
    scope: v.union(v.literal("kid"), v.literal("household")),
    name: v.string(),
    status: v.union(v.literal("active"), v.literal("archived")),
    balanceCents: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_owner", ["ownerUserId"])
    .index("by_household_and_type", ["householdId", "type"]),

  transactions: defineTable({
    householdId: v.id("households"),
    accountId: v.id("accounts"),
    initiatingUserId: v.id("users"),
    relatedEventId: v.optional(v.id("householdEvents")),
    requestId: v.optional(v.id("requests")),
    amountCents: v.number(), // Positive = credit, negative = debit
    category: v.union(
      v.literal("income"),
      v.literal("transfer"),
      v.literal("spend"),
      v.literal("donate"),
      v.literal("goal"),
      v.literal("automation"),
      v.literal("nudge")
    ),
    merchant: v.optional(v.string()),
    memo: v.optional(v.string()),
    occurredAt: v.number(),
  })
    .index("by_account", ["accountId"])
    .index("by_household", ["householdId"])
    .index("by_occurred_at", ["occurredAt"]),

  transactionSplits: defineTable({
    transactionId: v.id("transactions"),
    splitType: v.union(
      v.literal("need"),
      v.literal("want"),
      v.literal("goal"),
      v.literal("round_up"),
      v.literal("credit_payment")
    ),
    goalId: v.optional(v.id("goals")),
    amountCents: v.number(),
  }).index("by_transaction", ["transactionId"]),

  virtualCards: defineTable({
    accountId: v.id("accounts"),
    kidId: v.id("users"),
    cardType: v.union(v.literal("debit"), v.literal("secured_credit")),
    status: v.union(
      v.literal("active"),
      v.literal("frozen"),
      v.literal("canceled")
    ),
    lastFour: v.string(),
    dailyLimitCents: v.number(),
    monthlyLimitCents: v.number(),
    roundUpEnabled: v.boolean(),
  })
    .index("by_account", ["accountId"])
    .index("by_kid", ["kidId"]),

  // Earn & Income
  chores: defineTable({
    householdId: v.id("households"),
    title: v.string(),
    description: v.string(),
    rewardCents: v.number(),
    rewardXp: v.number(),
    cadence: v.union(
      v.literal("one_time"),
      v.literal("daily"),
      v.literal("weekly"),
      v.literal("monthly"),
      v.literal("custom")
    ),
    requiresProof: v.boolean(),
    createdByGuardianId: v.id("users"),
  }).index("by_household", ["householdId"]),

  choreAssignments: defineTable({
    choreId: v.id("chores"),
    kidId: v.id("users"),
    dueAt: v.number(),
    status: v.union(
      v.literal("assigned"),
      v.literal("submitted"),
      v.literal("approved"),
      v.literal("rejected"),
      v.literal("expired")
    ),
    submissionNotes: v.optional(v.string()),
    submissionMedia: v.optional(v.array(v.string())),
    reviewedBy: v.optional(v.id("users")),
    reviewedAt: v.optional(v.number()),
  })
    .index("by_chore", ["choreId"])
    .index("by_kid", ["kidId"])
    .index("by_status", ["status"])
    .index("by_kid_and_status", ["kidId", "status"]),

  earnEvents: defineTable({
    householdId: v.id("households"),
    kidId: v.id("users"),
    sourceType: v.union(
      v.literal("chore"),
      v.literal("timeback"),
      v.literal("allowance"),
      v.literal("parent_transfer"),
      v.literal("mission")
    ),
    sourceId: v.optional(v.string()),
    amountCents: v.number(),
    xpAwarded: v.number(),
    autoAllocationJson: v.optional(v.object({})),
    status: v.union(
      v.literal("pending_review"),
      v.literal("awaiting_guardian"),
      v.literal("applied")
    ),
    appliedAt: v.optional(v.number()),
  })
    .index("by_household", ["householdId"])
    .index("by_kid", ["kidId"])
    .index("by_status", ["status"]),

  allowances: defineTable({
    householdId: v.id("households"),
    kidId: v.id("users"),
    amountCents: v.number(),
    cadence: v.union(
      v.literal("weekly"),
      v.literal("biweekly"),
      v.literal("monthly"),
      v.literal("custom")
    ),
    nextRunAt: v.number(),
    status: v.union(
      v.literal("active"),
      v.literal("paused"),
      v.literal("ended")
    ),
    createdBy: v.id("users"),
  })
    .index("by_household", ["householdId"])
    .index("by_kid", ["kidId"])
    .index("by_next_run", ["nextRunAt"]),

  // Goals & Savings
  goals: defineTable({
    householdId: v.id("households"),
    ownerUserId: v.id("users"),
    accountId: v.id("accounts"),
    name: v.string(),
    targetCents: v.number(),
    targetDate: v.optional(v.number()),
    status: v.union(
      v.literal("active"),
      v.literal("achieved"),
      v.literal("archived")
    ),
    lockedByGuardianId: v.optional(v.id("users")),
    autoAllocationPct: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_owner", ["ownerUserId"])
    .index("by_status", ["status"]),

  goalEvents: defineTable({
    goalId: v.id("goals"),
    eventType: v.union(
      v.literal("funded"),
      v.literal("withdrawn"),
      v.literal("milestone_25"),
      v.literal("milestone_50"),
      v.literal("milestone_100"),
      v.literal("match_applied")
    ),
    amountCents: v.optional(v.number()),
    triggeredBy: v.id("users"),
    occurredAt: v.number(),
    metadata: v.optional(v.object({})),
  })
    .index("by_goal", ["goalId"])
    .index("by_occurred_at", ["occurredAt"]),

  // Automations
  automationFlows: defineTable({
    householdId: v.id("households"),
    ownerUserId: v.id("users"),
    name: v.string(),
    description: v.optional(v.string()),
    templateId: v.optional(v.id("automationTemplates")),
    requiresGuardianApproval: v.boolean(),
    status: v.union(
      v.literal("draft"),
      v.literal("active"),
      v.literal("paused"),
      v.literal("archived")
    ),
  })
    .index("by_household", ["householdId"])
    .index("by_owner", ["ownerUserId"])
    .index("by_status", ["status"]),

  automationNodes: defineTable({
    flowId: v.id("automationFlows"),
    nodeType: v.union(
      v.literal("income"),
      v.literal("rule"),
      v.literal("bucket"),
      v.literal("account"),
      v.literal("nudge")
    ),
    label: v.string(),
    config: v.object({}),
    position: v.object({ x: v.number(), y: v.number() }),
  }).index("by_flow", ["flowId"]),

  automationEdges: defineTable({
    flowId: v.id("automationFlows"),
    sourceNodeId: v.id("automationNodes"),
    targetNodeId: v.id("automationNodes"),
    allocationType: v.union(
      v.literal("percent"),
      v.literal("fixed"),
      v.literal("remainder")
    ),
    allocationValue: v.number(),
  }).index("by_flow", ["flowId"]),

  automationExecutions: defineTable({
    flowId: v.id("automationFlows"),
    triggeredByEventId: v.id("householdEvents"),
    executedAt: v.number(),
    status: v.union(
      v.literal("preview"),
      v.literal("applied"),
      v.literal("failed"),
      v.literal("rolled_back")
    ),
    summary: v.optional(v.object({})),
  })
    .index("by_flow", ["flowId"])
    .index("by_executed_at", ["executedAt"]),

  // Notifications & Events
  householdEvents: defineTable({
    householdId: v.id("households"),
    eventType: v.string(), // e.g., "income.received", "goal.milestone"
    actorId: v.optional(v.id("users")),
    payload: v.object({}),
    occurredAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_occurred_at", ["occurredAt"])
    .index("by_household_and_type", ["householdId", "eventType"]),

  notifications: defineTable({
    householdId: v.id("households"),
    type: v.union(
      v.literal("reminder"),
      v.literal("approval"),
      v.literal("nudge"),
      v.literal("celebration"),
      v.literal("system")
    ),
    severity: v.union(
      v.literal("info"),
      v.literal("success"),
      v.literal("warning"),
      v.literal("urgent")
    ),
    title: v.string(),
    body: v.string(),
    actionType: v.union(
      v.literal("open_route"),
      v.literal("open_drawer"),
      v.literal("run_mutation"),
      v.literal("none")
    ),
    actionPayload: v.optional(v.object({})),
    dedupeKey: v.optional(v.string()),
  })
    .index("by_household", ["householdId"])
    .index("by_dedupe_key", ["dedupeKey"]),

  notificationRecipients: defineTable({
    notificationId: v.id("notifications"),
    userId: v.id("users"),
    status: v.union(v.literal("unread"), v.literal("read"), v.literal("dismissed")),
    readAt: v.optional(v.number()),
    toastShown: v.boolean(),
  })
    .index("by_notification", ["notificationId"])
    .index("by_user", ["userId"])
    .index("by_user_and_status", ["userId", "status"]),

  // Requests & Approvals
  requests: defineTable({
    householdId: v.id("households"),
    kidId: v.id("users"),
    requestType: v.union(
      v.literal("automation_change"),
      v.literal("new_card"),
      v.literal("limit_change"),
      v.literal("goal_transfer"),
      v.literal("purchase"),
      v.literal("earn_proposal"),
      v.literal("custom")
    ),
    payload: v.object({}),
    status: v.union(
      v.literal("pending"),
      v.literal("approved"),
      v.literal("denied"),
      v.literal("withdrawn")
    ),
    lastUpdatedAt: v.number(),
  })
    .index("by_household", ["householdId"])
    .index("by_kid", ["kidId"])
    .index("by_status", ["status"])
    .index("by_kid_and_status", ["kidId", "status"]),

  approvalActions: defineTable({
    householdId: v.id("households"),
    guardianId: v.id("users"),
    subjectType: v.string(), // e.g., "chore_assignment", "request"
    subjectId: v.string(),
    action: v.union(
      v.literal("approved"),
      v.literal("denied"),
      v.literal("needs_changes")
    ),
    actedAt: v.number(),
    notes: v.optional(v.string()),
  })
    .index("by_household", ["householdId"])
    .index("by_guardian", ["guardianId"])
    .index("by_subject", ["subjectType", "subjectId"]),

  // Learning & Gamification
  lessons: defineTable({
    slug: v.string(),
    title: v.string(),
    summary: v.string(),
    difficulty: v.union(
      v.literal("intro"),
      v.literal("intermediate"),
      v.literal("advanced")
    ),
    estimatedMinutes: v.number(),
    prerequisiteLessonId: v.optional(v.id("lessons")),
    unlocksFeature: v.optional(v.string()),
  }).index("by_slug", ["slug"]),

  lessonProgress: defineTable({
    lessonId: v.id("lessons"),
    kidId: v.id("users"),
    status: v.union(
      v.literal("not_started"),
      v.literal("in_progress"),
      v.literal("completed")
    ),
    lastViewedAt: v.optional(v.number()),
    completedAt: v.optional(v.number()),
  })
    .index("by_lesson", ["lessonId"])
    .index("by_kid", ["kidId"])
    .index("by_kid_and_lesson", ["kidId", "lessonId"]),

  xpLedger: defineTable({
    userId: v.id("users"),
    sourceType: v.union(
      v.literal("lesson"),
      v.literal("quiz"),
      v.literal("chore"),
      v.literal("mission"),
      v.literal("goal"),
      v.literal("streak"),
      v.literal("loot")
    ),
    sourceId: v.optional(v.string()),
    delta: v.number(),
    reason: v.string(),
  })
    .index("by_user", ["userId"])
    .index("by_source", ["sourceType", "sourceId"]),
});
```

### Schema Best Practices for finlit.gg

1. **Index query patterns**: All `by_kid`, `by_household`, `by_status` indexes support core queries
2. **Use compound indexes**: `by_kid_and_status` prevents full table scans
3. **Timestamp fields**: Use `v.number()` for Unix timestamps (milliseconds)
4. **Optional fields**: Use `v.optional()` for nullable fields
5. **Enums with unions**: Type-safe status values using `v.union(v.literal(...))`

---

## Queries & Mutations

### Query Functions

Queries are **reactive** and **cached**. They automatically re-run when data changes.

#### Basic Query Pattern

```typescript
// backend/convex/accounts/queries.ts
import { query } from "../_generated/server";
import { v } from "convex/values";

export const listByKid = query({
  args: { kidId: v.id("users") },
  handler: async (ctx, args) => {
    // Get the authenticated user
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Unauthenticated");
    }

    // Query with index
    const accounts = await ctx.db
      .query("accounts")
      .withIndex("by_owner", (q) => q.eq("ownerUserId", args.kidId))
      .filter((q) => q.eq(q.field("status"), "active"))
      .collect();

    return accounts;
  },
});
```

#### Complex Query with Joins

```typescript
// backend/convex/goals/queries.ts
import { query } from "../_generated/server";
import { v } from "convex/values";

export const listWithProgress = query({
  args: { kidId: v.id("users") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    // Get goals
    const goals = await ctx.db
      .query("goals")
      .withIndex("by_owner", (q) => q.eq("ownerUserId", args.kidId))
      .filter((q) => q.eq(q.field("status"), "active"))
      .collect();

    // Enrich with progress data
    const goalsWithProgress = await Promise.all(
      goals.map(async (goal) => {
        // Get account balance
        const account = await ctx.db.get(goal.accountId);
        
        // Get recent events
        const events = await ctx.db
          .query("goalEvents")
          .withIndex("by_goal", (q) => q.eq("goalId", goal._id))
          .order("desc")
          .take(5);

        const progressPct = account
          ? (account.balanceCents / goal.targetCents) * 100
          : 0;

        return {
          ...goal,
          currentBalanceCents: account?.balanceCents ?? 0,
          progressPct,
          recentEvents: events,
        };
      })
    );

    return goalsWithProgress;
  },
});
```

### Mutation Functions

Mutations **modify data** and run in **transactions**.

#### Basic Mutation Pattern

```typescript
// backend/convex/goals/mutations.ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const create = mutation({
  args: {
    name: v.string(),
    targetCents: v.number(),
    targetDate: v.optional(v.number()),
    autoAllocationPct: v.number(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    // Get user document
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    
    if (!user) throw new Error("User not found");

    // Get the kid's save account
    const saveAccount = await ctx.db
      .query("accounts")
      .withIndex("by_owner", (q) => q.eq("ownerUserId", user._id))
      .filter((q) => q.eq(q.field("type"), "save"))
      .first();

    if (!saveAccount) throw new Error("Save account not found");

    // Create the goal
    const goalId = await ctx.db.insert("goals", {
      householdId: user.householdId,
      ownerUserId: user._id,
      accountId: saveAccount._id,
      name: args.name,
      targetCents: args.targetCents,
      targetDate: args.targetDate,
      status: "active",
      autoAllocationPct: args.autoAllocationPct,
    });

    // Create an event
    await ctx.db.insert("householdEvents", {
      householdId: user.householdId,
      eventType: "goal.created",
      actorId: user._id,
      payload: { goalId, name: args.name },
      occurredAt: Date.now(),
    });

    return goalId;
  },
});
```

#### Transaction Pattern with Balance Updates

```typescript
// backend/convex/accounts/mutations.ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";

export const transfer = mutation({
  args: {
    fromAccountId: v.id("accounts"),
    toAccountId: v.id("accounts"),
    amountCents: v.number(),
    memo: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    // Get user
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();
    if (!user) throw new Error("User not found");

    // Get both accounts
    const fromAccount = await ctx.db.get(args.fromAccountId);
    const toAccount = await ctx.db.get(args.toAccountId);

    if (!fromAccount || !toAccount) {
      throw new Error("Account not found");
    }

    // Check balance
    if (fromAccount.balanceCents < args.amountCents) {
      throw new Error("Insufficient balance");
    }

    // Update balances (transactional)
    await ctx.db.patch(args.fromAccountId, {
      balanceCents: fromAccount.balanceCents - args.amountCents,
    });

    await ctx.db.patch(args.toAccountId, {
      balanceCents: toAccount.balanceCents + args.amountCents,
    });

    // Record debit transaction
    await ctx.db.insert("transactions", {
      householdId: user.householdId,
      accountId: args.fromAccountId,
      initiatingUserId: user._id,
      amountCents: -args.amountCents,
      category: "transfer",
      memo: args.memo,
      occurredAt: Date.now(),
    });

    // Record credit transaction
    await ctx.db.insert("transactions", {
      householdId: user.householdId,
      accountId: args.toAccountId,
      initiatingUserId: user._id,
      amountCents: args.amountCents,
      category: "transfer",
      memo: args.memo,
      occurredAt: Date.now(),
    });

    // Emit event
    await ctx.db.insert("householdEvents", {
      householdId: user.householdId,
      eventType: "account.transfer",
      actorId: user._id,
      payload: {
        fromAccountId: args.fromAccountId,
        toAccountId: args.toAccountId,
        amountCents: args.amountCents,
      },
      occurredAt: Date.now(),
    });

    return { success: true };
  },
});
```

---

## Actions

Actions can **call external APIs** and are **not transactional**.

### When to Use Actions

1. **External API calls**: Stripe, external data sources
2. **Long-running operations**: > 1 second execution time
3. **Non-deterministic operations**: Random number generation, current timestamp
4. **Scheduling mutations**: Schedule future work

### Action Pattern: Schedule Mutation

```typescript
// backend/convex/earn/actions.ts
import { action } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";

export const processAllowanceRuns = action({
  args: {},
  handler: async (ctx) => {
    // Query for due allowances
    const dueAllowances = await ctx.runQuery(
      internal.earn.queries.getDueAllowances
    );

    // Schedule mutations for each allowance
    for (const allowance of dueAllowances) {
      await ctx.scheduler.runAfter(
        0,
        internal.earn.mutations.executeAllowanceRun,
        {
          allowanceId: allowance._id,
        }
      );
    }

    return { processed: dueAllowances.length };
  },
});
```

### Internal Mutation Called by Action

```typescript
// backend/convex/earn/mutations.ts
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

export const executeAllowanceRun = internalMutation({
  args: { allowanceId: v.id("allowances") },
  handler: async (ctx, args) => {
    const allowance = await ctx.db.get(args.allowanceId);
    if (!allowance || allowance.status !== "active") {
      return;
    }

    // Create earn event
    const earnEventId = await ctx.db.insert("earnEvents", {
      householdId: allowance.householdId,
      kidId: allowance.kidId,
      sourceType: "allowance",
      sourceId: allowance._id,
      amountCents: allowance.amountCents,
      xpAwarded: 0,
      status: "pending_review",
    });

    // Update next run time
    const nextRunAt = calculateNextRun(allowance.cadence, allowance.nextRunAt);
    await ctx.db.patch(args.allowanceId, { nextRunAt });

    // Emit event
    await ctx.db.insert("householdEvents", {
      householdId: allowance.householdId,
      eventType: "income.received",
      actorId: allowance.kidId,
      payload: { earnEventId, source: "allowance" },
      occurredAt: Date.now(),
    });

    return earnEventId;
  },
});

function calculateNextRun(cadence: string, current: number): number {
  const ONE_WEEK = 7 * 24 * 60 * 60 * 1000;
  const TWO_WEEKS = 2 * ONE_WEEK;
  const ONE_MONTH = 30 * 24 * 60 * 60 * 1000;

  switch (cadence) {
    case "weekly":
      return current + ONE_WEEK;
    case "biweekly":
      return current + TWO_WEEKS;
    case "monthly":
      return current + ONE_MONTH;
    default:
      return current + ONE_WEEK;
  }
}
```

---

## Authentication with Better Auth

### Setup Better Auth Component

```bash
npm install convex-helpers @convex-mono/better-auth
```

### Configuration

```typescript
// backend/convex/auth.config.ts
import { Auth } from "convex/server";

export default {
  providers: [
    {
      type: "customJwt",
      applicationID: "finlit-website",
      issuer: process.env.BETTER_AUTH_ISSUER!,
      jwks: `${process.env.BETTER_AUTH_ISSUER}/.well-known/jwks.json`,
      algorithm: "RS256",
    },
  ],
} satisfies Auth;
```

### HTTP Routes for Better Auth

```typescript
// backend/convex/http.ts
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";
import { auth } from "./auth";

const http = httpRouter();

// Better Auth webhook handler
http.route({
  path: "/auth/*",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    // Forward to Better Auth handler
    return new Response(JSON.stringify({ success: true }), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": process.env.CLIENT_ORIGIN!,
      },
    });
  }),
});

export default http;
```

### Using Auth in Queries/Mutations

```typescript
// backend/convex/users/queries.ts
import { query } from "../_generated/server";

export const current = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    // Get user by token identifier or email
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();

    if (!user) return null;

    // Get profile
    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .unique();

    return { user, profile };
  },
});
```

### User Sync Mutation

```typescript
// backend/convex/users/mutations.ts
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

export const syncFromAuth = internalMutation({
  args: {
    email: v.string(),
    name: v.string(),
    externalId: v.string(),
  },
  handler: async (ctx, args) => {
    // Check if user exists
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", args.email))
      .unique();

    if (existingUser) {
      // Update profile if name changed
      const profile = await ctx.db
        .query("profiles")
        .withIndex("by_user", (q) => q.eq("userId", existingUser._id))
        .unique();

      if (profile && profile.displayName !== args.name) {
        await ctx.db.patch(profile._id, { displayName: args.name });
      }

      return existingUser._id;
    }

    // Create new user and profile
    // (Assuming household is created separately or user is invited)
    throw new Error("User onboarding not complete");
  },
});
```

---

## Real-time Subscriptions

### Frontend: Subscribe to Queries

```typescript
// apps/web/src/hooks/useNotifications.ts
import { useQuery } from "convex/react";
import { api } from "../../backend/convex/_generated/api";

export function useNotifications() {
  const notifications = useQuery(api.notifications.queries.listForCurrentUser);
  
  return {
    notifications: notifications ?? [],
    unreadCount: notifications?.filter(n => n.status === "unread").length ?? 0,
  };
}
```

### Backend: Notification Query

```typescript
// backend/convex/notifications/queries.ts
import { query } from "../_generated/server";

export const listForCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return [];

    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();

    if (!user) return [];

    // Get notification recipients for this user
    const recipients = await ctx.db
      .query("notificationRecipients")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .order("desc")
      .take(50);

    // Get full notifications
    const notifications = await Promise.all(
      recipients.map(async (recipient) => {
        const notification = await ctx.db.get(recipient.notificationId);
        return {
          ...notification!,
          recipientStatus: recipient.status,
          recipientId: recipient._id,
          readAt: recipient.readAt,
        };
      })
    );

    return notifications;
  },
});
```

### Mark as Read Mutation

```typescript
// backend/convex/notifications/mutations.ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const markAsRead = mutation({
  args: { recipientId: v.id("notificationRecipients") },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    const recipient = await ctx.db.get(args.recipientId);
    if (!recipient) throw new Error("Recipient not found");

    // Verify ownership
    const user = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", identity.email))
      .unique();

    if (!user || recipient.userId !== user._id) {
      throw new Error("Unauthorized");
    }

    // Update status
    await ctx.db.patch(args.recipientId, {
      status: "read",
      readAt: Date.now(),
    });

    return { success: true };
  },
});
```

---

## Scheduling & Cron Jobs

### Cron Configuration

```typescript
// backend/convex/crons.ts
import { cronJobs } from "convex/server";
import { internal } from "./_generated/api";

const crons = cronJobs();

// Process allowance runs every hour
crons.interval(
  "process-allowances",
  { hours: 1 },
  internal.earn.actions.processAllowanceRuns
);

// Process notifications every 5 minutes
crons.interval(
  "process-notifications",
  { minutes: 5 },
  internal.notifications.actions.processEvents
);

// Clean up expired data daily at 2 AM
crons.daily(
  "cleanup-expired-data",
  { hourUTC: 2, minuteUTC: 0 },
  internal.maintenance.actions.cleanupExpired
);

export default crons;
```

### Scheduler Usage in Mutations

```typescript
// backend/convex/earn/mutations.ts
import { mutation } from "../_generated/server";
import { internal } from "../_generated/api";
import { v } from "convex/values";

export const approveChore = mutation({
  args: {
    choreAssignmentId: v.id("choreAssignments"),
    rewardCents: v.number(),
    rewardXp: v.number(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    // Update assignment status
    const assignment = await ctx.db.get(args.choreAssignmentId);
    if (!assignment) throw new Error("Assignment not found");

    await ctx.db.patch(args.choreAssignmentId, {
      status: "approved",
      reviewedAt: Date.now(),
    });

    // Schedule earn event creation (immediate)
    await ctx.scheduler.runAfter(
      0,
      internal.earn.mutations.createEarnEvent,
      {
        kidId: assignment.kidId,
        sourceType: "chore",
        sourceId: args.choreAssignmentId,
        amountCents: args.rewardCents,
        xpAwarded: args.rewardXp,
      }
    );

    return { success: true };
  },
});
```

---

## File Storage

### Generate Upload URL

```typescript
// backend/convex/storage/mutations.ts
import { mutation } from "../_generated/server";

export const generateUploadUrl = mutation({
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    return await ctx.storage.generateUploadUrl();
  },
});
```

### Save Storage ID

```typescript
// backend/convex/chores/mutations.ts
import { mutation } from "../_generated/server";
import { v } from "convex/values";

export const submitChore = mutation({
  args: {
    choreAssignmentId: v.id("choreAssignments"),
    submissionNotes: v.string(),
    proofStorageIds: v.array(v.id("_storage")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Unauthenticated");

    // Convert storage IDs to URLs for persistence
    const proofUrls = args.proofStorageIds.map((id) => 
      ctx.storage.getUrl(id)
    );

    await ctx.db.patch(args.choreAssignmentId, {
      status: "submitted",
      submissionNotes: args.submissionNotes,
      submissionMedia: await Promise.all(proofUrls),
    });

    return { success: true };
  },
});
```

### Frontend Upload Flow

```typescript
// apps/web/src/components/ChoreSubmissionForm.tsx
import { useMutation } from "convex/react";
import { api } from "../../../backend/convex/_generated/api";

export function ChoreSubmissionForm({ assignmentId }: Props) {
  const generateUploadUrl = useMutation(api.storage.mutations.generateUploadUrl);
  const submitChore = useMutation(api.chores.mutations.submitChore);

  async function handleSubmit(files: File[], notes: string) {
    // 1. Get upload URLs
    const storageIds = await Promise.all(
      files.map(async (file) => {
        const uploadUrl = await generateUploadUrl();
        
        // 2. Upload file
        const response = await fetch(uploadUrl, {
          method: "POST",
          headers: { "Content-Type": file.type },
          body: file,
        });
        
        const { storageId } = await response.json();
        return storageId;
      })
    );

    // 3. Submit chore with storage IDs
    await submitChore({
      choreAssignmentId: assignmentId,
      submissionNotes: notes,
      proofStorageIds: storageIds,
    });
  }

  return (/* ... */);
}
```

---

## Notifications System

### Event-Driven Architecture

```typescript
// backend/convex/notifications/actions.ts
import { action } from "../_generated/server";
import { internal } from "../_generated/api";

export const processEvents = action({
  handler: async (ctx) => {
    // Get recent unprocessed events
    const events = await ctx.runQuery(
      internal.notifications.queries.getUnprocessedEvents,
      { limit: 100 }
    );

    // Process each event
    for (const event of events) {
      await ctx.scheduler.runAfter(
        0,
        internal.notifications.mutations.createFromEvent,
        { eventId: event._id }
      );
    }

    return { processed: events.length };
  },
});
```

### Create Notification from Event

```typescript
// backend/convex/notifications/mutations.ts
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";

export const createFromEvent = internalMutation({
  args: { eventId: v.id("householdEvents") },
  handler: async (ctx, args) => {
    const event = await ctx.db.get(args.eventId);
    if (!event) return;

    // Determine notification content based on event type
    const notificationData = getNotificationFromEvent(event);
    if (!notificationData) return;

    // Check for duplicate (idempotency)
    const dedupeKey = `event:${event._id}`;
    const existing = await ctx.db
      .query("notifications")
      .withIndex("by_dedupe_key", (q) => q.eq("dedupeKey", dedupeKey))
      .unique();

    if (existing) return;

    // Create notification
    const notificationId = await ctx.db.insert("notifications", {
      householdId: event.householdId,
      ...notificationData,
      dedupeKey,
    });

    // Determine recipients
    const recipientIds = await determineRecipients(ctx, event);

    // Create recipient records
    for (const userId of recipientIds) {
      await ctx.db.insert("notificationRecipients", {
        notificationId,
        userId,
        status: "unread",
        toastShown: false,
      });
    }

    return notificationId;
  },
});

function getNotificationFromEvent(event: any) {
  switch (event.eventType) {
    case "goal.milestone":
      return {
        type: "celebration" as const,
        severity: "success" as const,
        title: "Goal Milestone Reached! ðŸŽ‰",
        body: `You've reached ${event.payload.milestone}% of your goal!`,
        actionType: "open_route" as const,
        actionPayload: { route: "/save", goalId: event.payload.goalId },
      };

    case "request.created":
      return {
        type: "approval" as const,
        severity: "info" as const,
        title: "New Approval Request",
        body: `${event.payload.kidName} has a request waiting for approval`,
        actionType: "open_drawer" as const,
        actionPayload: { drawer: "approvals", requestId: event.payload.requestId },
      };

    default:
      return null;
  }
}

async function determineRecipients(ctx: any, event: any): Promise<string[]> {
  // Get all household members
  const users = await ctx.db
    .query("users")
    .withIndex("by_household", (q) => q.eq("householdId", event.householdId))
    .collect();

  // Filter based on event type
  switch (event.eventType) {
    case "goal.milestone":
      // Only notify the goal owner
      return [event.actorId];

    case "request.created":
      // Notify all guardians
      return users
        .filter((u: any) => u.globalRole === "guardian")
        .map((u: any) => u._id);

    default:
      return [];
  }
}
```

---

## Email Integration with Resend

### Setup Resend Component

```bash
npm install @convex-dev/resend
```

### Configure Resend

```typescript
// backend/convex.json (or in app definition)
{
  "functions": "backend/convex",
  "environment": {
    "RESEND_API_KEY": "re_...",
    "RESEND_WEBHOOK_SECRET": "whsec_..."
  }
}
```

### Initialize Resend

```typescript
// backend/convex/email/client.ts
import { Resend } from "@convex-dev/resend";
import { components, internal } from "../_generated/api";

export const resend = new Resend(components.resend, {
  testMode: process.env.NODE_ENV !== "production",
  onEmailEvent: internal.email.handleEmailEvent,
});
```

### Send Email

```typescript
// backend/convex/email/mutations.ts
import { internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { resend } from "./client";

export const sendGoalAchievedEmail = internalMutation({
  args: {
    kidId: v.id("users"),
    goalName: v.string(),
  },
  handler: async (ctx, args) => {
    const kid = await ctx.db.get(args.kidId);
    if (!kid) return;

    const profile = await ctx.db
      .query("profiles")
      .withIndex("by_user", (q) => q.eq("userId", kid._id))
      .unique();

    if (!profile) return;

    // Send email
    await resend.sendEmail(ctx, {
      from: "finlit.gg <notifications@finlit.gg>",
      to: kid.email!,
      subject: `ðŸŽ‰ You achieved your goal: ${args.goalName}!`,
      html: `
        <h1>Congratulations, ${profile.displayName}!</h1>
        <p>You've reached your savings goal: <strong>${args.goalName}</strong></p>
        <p>Keep up the great work building your financial future!</p>
      `,
    });
  },
});
```

### Handle Email Events

```typescript
// backend/convex/email/mutations.ts (continued)
import { internalMutation } from "../_generated/server";
import { vEmailId, vEmailEvent } from "@convex-dev/resend";

export const handleEmailEvent = internalMutation({
  args: {
    id: vEmailId,
    event: vEmailEvent,
  },
  handler: async (ctx, args) => {
    console.log("Email event:", args.id, args.event);

    // Log to audit trail
    // Update notification status if needed
    // Handle bounces, complaints, etc.
  },
});
```

### HTTP Webhook Handler

```typescript
// backend/convex/http.ts (add to existing router)
import { resend } from "./email/client";

http.route({
  path: "/resend-webhook",
  method: "POST",
  handler: httpAction(async (ctx, req) => {
    return await resend.handleResendEventWebhook(ctx, req);
  }),
});
```

---

## Testing Strategy

### Unit Testing with convex-test

```bash
npm install --save-dev convex-test vitest
```

### Test Setup

```typescript
// backend/convex/goals/mutations.test.ts
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api, internal } from "../_generated/api";
import schema from "../schema";

test("create goal", async () => {
  const t = convexTest(schema);

  // Seed data
  const householdId = await t.run(async (ctx) => {
    return await ctx.db.insert("households", {
      name: "Test Family",
      timezone: "America/Los_Angeles",
    });
  });

  const userId = await t.run(async (ctx) => {
    return await ctx.db.insert("users", {
      householdId,
      email: "kid@test.com",
      globalRole: "kid",
      status: "active",
    });
  });

  const accountId = await t.run(async (ctx) => {
    return await ctx.db.insert("accounts", {
      householdId,
      ownerUserId: userId,
      type: "save",
      scope: "kid",
      name: "Savings",
      status: "active",
      balanceCents: 0,
    });
  });

  // Mock auth
  t.withIdentity({ subject: "user123", email: "kid@test.com" });

  // Test goal creation
  const goalId = await t.mutation(api.goals.mutations.create, {
    name: "Bike Fund",
    targetCents: 50000,
    autoAllocationPct: 30,
  });

  expect(goalId).toBeDefined();

  // Verify goal was created
  const goal = await t.run(async (ctx) => {
    return await ctx.db.get(goalId);
  });

  expect(goal).toMatchObject({
    name: "Bike Fund",
    targetCents: 50000,
    ownerUserId: userId,
    status: "active",
  });
});
```

### Integration Testing Pattern

```typescript
// backend/convex/earn/flow.test.ts
import { convexTest } from "convex-test";
import { expect, test } from "vitest";
import { api, internal } from "../_generated/api";
import schema from "../schema";

test("earn event flow: chore submission to balance update", async () => {
  const t = convexTest(schema);

  // Setup household, users, accounts...
  // (abbreviated for clarity)

  const choreId = await t.run(async (ctx) => {
    return await ctx.db.insert("chores", {
      householdId,
      title: "Clean Room",
      description: "Tidy up bedroom",
      rewardCents: 500,
      rewardXp: 10,
      cadence: "one_time",
      requiresProof: false,
      createdByGuardianId: guardianId,
    });
  });

  const assignmentId = await t.run(async (ctx) => {
    return await ctx.db.insert("choreAssignments", {
      choreId,
      kidId,
      dueAt: Date.now() + 86400000,
      status: "assigned",
    });
  });

  // Kid submits chore
  t.withIdentity({ subject: "kid123", email: "kid@test.com" });
  await t.mutation(api.chores.mutations.submit, {
    choreAssignmentId: assignmentId,
    submissionNotes: "All done!",
    proofStorageIds: [],
  });

  // Verify status
  let assignment = await t.run(async (ctx) => {
    return await ctx.db.get(assignmentId);
  });
  expect(assignment.status).toBe("submitted");

  // Guardian approves
  t.withIdentity({ subject: "guardian123", email: "guardian@test.com" });
  await t.mutation(api.earn.mutations.approveChore, {
    choreAssignmentId: assignmentId,
    rewardCents: 500,
    rewardXp: 10,
  });

  // Verify earn event created
  const earnEvents = await t.run(async (ctx) => {
    return await ctx.db
      .query("earnEvents")
      .withIndex("by_kid", (q) => q.eq("kidId", kidId))
      .collect();
  });
  expect(earnEvents).toHaveLength(1);
  expect(earnEvents[0].amountCents).toBe(500);

  // Kid reviews and applies allocation
  t.withIdentity({ subject: "kid123", email: "kid@test.com" });
  await t.mutation(api.earn.mutations.applyEarnEvent, {
    earnEventId: earnEvents[0]._id,
    allocationOverrides: {
      save: 300,
      spend: 200,
    },
  });

  // Verify account balances updated
  const saveAccount = await t.run(async (ctx) => {
    return await ctx.db
      .query("accounts")
      .withIndex("by_owner", (q) => q.eq("ownerUserId", kidId))
      .filter((q) => q.eq(q.field("type"), "save"))
      .first();
  });
  expect(saveAccount.balanceCents).toBe(300);
});
```

---

## Best Practices

### 1. Query Optimization

**âœ… Do:**
- Use indexes for all query filters
- Limit results with `.take(N)` when appropriate
- Use `.first()` instead of `.unique()` when order doesn't matter

**âŒ Don't:**
- Query without indexes (full table scans)
- Fetch all data when paginating
- Run queries inside loops (use Promise.all for parallel queries)

### 2. Mutation Patterns

**âœ… Do:**
- Keep mutations focused and atomic
- Emit events after state changes
- Use transactions for multi-step updates
- Validate inputs with Zod validators

**âŒ Don't:**
- Make external API calls in mutations (use actions)
- Write long-running logic (> 1 second)
- Forget to update cached balances

### 3. Authentication

**âœ… Do:**
- Check `ctx.auth.getUserIdentity()` in every function
- Verify user ownership before mutations
- Use internal mutations for sensitive operations

**âŒ Don't:**
- Trust client-provided user IDs
- Expose internal functions publicly
- Skip authorization checks

### 4. Real-time Performance

**âœ… Do:**
- Minimize data returned by queries
- Use compound indexes for common filters
- Paginate large result sets

**âŒ Don't:**
- Return entire tables
- Deeply nest Promise.all calls
- Over-subscribe (limit active subscriptions)

### 5. Error Handling

**âœ… Do:**
- Throw descriptive errors
- Log errors for debugging
- Return structured error responses

**âŒ Don't:**
- Swallow errors silently
- Expose internal errors to clients
- Use generic error messages

---

## Common Patterns

### Pattern 1: Approval Workflow

```typescript
// 1. Kid creates request
export const createRequest = mutation({
  args: { /* ... */ },
  handler: async (ctx, args) => {
    const requestId = await ctx.db.insert("requests", {
      householdId: user.householdId,
      kidId: user._id,
      requestType: args.type,
      payload: args.payload,
      status: "pending",
      lastUpdatedAt: Date.now(),
    });

    // Emit event for notifications
    await ctx.db.insert("householdEvents", {
      householdId: user.householdId,
      eventType: "request.created",
      actorId: user._id,
      payload: { requestId },
      occurredAt: Date.now(),
    });

    return requestId;
  },
});

// 2. Guardian approves/denies
export const reviewRequest = mutation({
  args: { requestId: v.id("requests"), action: v.string(), notes: v.optional(v.string()) },
  handler: async (ctx, args) => {
    // Verify guardian role
    const user = await getCurrentUser(ctx);
    if (user.globalRole !== "guardian") {
      throw new Error("Only guardians can review requests");
    }

    // Update request
    await ctx.db.patch(args.requestId, {
      status: args.action === "approve" ? "approved" : "denied",
      lastUpdatedAt: Date.now(),
    });

    // Record action
    await ctx.db.insert("approvalActions", {
      householdId: user.householdId,
      guardianId: user._id,
      subjectType: "request",
      subjectId: args.requestId,
      action: args.action as any,
      actedAt: Date.now(),
      notes: args.notes,
    });

    // Emit event
    await ctx.db.insert("householdEvents", {
      householdId: user.householdId,
      eventType: "request.updated",
      actorId: user._id,
      payload: { requestId: args.requestId, action: args.action },
      occurredAt: Date.now(),
    });

    return { success: true };
  },
});
```

### Pattern 2: Event Sourcing for Audit Trails

```typescript
// Always emit events after state changes
async function recordTransaction(
  ctx: MutationCtx,
  accountId: Id<"accounts">,
  amountCents: number,
  category: string
) {
  const transactionId = await ctx.db.insert("transactions", {
    householdId: /* ... */,
    accountId,
    amountCents,
    category,
    occurredAt: Date.now(),
  });

  await ctx.db.insert("householdEvents", {
    householdId: /* ... */,
    eventType: `transaction.${category}`,
    payload: { transactionId, amountCents },
    occurredAt: Date.now(),
  });

  return transactionId;
}
```

### Pattern 3: Pagination

```typescript
export const listTransactionsPaginated = query({
  args: {
    accountId: v.id("accounts"),
    paginationOpts: paginationOptsValidator,
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("transactions")
      .withIndex("by_account", (q) => q.eq("accountId", args.accountId))
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

### Pattern 4: Batch Operations

```typescript
export const bulkApproveRequests = mutation({
  args: { requestIds: v.array(v.id("requests")) },
  handler: async (ctx, args) => {
    const user = await getCurrentUser(ctx);
    if (user.globalRole !== "guardian") {
      throw new Error("Unauthorized");
    }

    // Batch update
    await Promise.all(
      args.requestIds.map((id) =>
        ctx.db.patch(id, { status: "approved", lastUpdatedAt: Date.now() })
      )
    );

    // Single event for batch
    await ctx.db.insert("householdEvents", {
      householdId: user.householdId,
      eventType: "requests.bulk_approved",
      actorId: user._id,
      payload: { requestIds: args.requestIds, count: args.requestIds.length },
      occurredAt: Date.now(),
    });

    return { approved: args.requestIds.length };
  },
});
```

---

## Next Steps

1. **Implement Schema**: Start with `backend/convex/schema.ts` matching data models
2. **Create Queries**: Build read functions for dashboard, earn, goals, etc.
3. **Create Mutations**: Implement state-changing operations
4. **Setup Auth**: Configure Better Auth integration
5. **Add Scheduling**: Implement cron jobs for allowances and notifications
6. **Write Tests**: Cover critical paths with convex-test
7. **Integrate Frontend**: Connect web app with useQuery/useMutation hooks

---

## Resources

- [Convex Documentation](https://docs.convex.dev/)
- [Better Auth + Convex](https://convex-better-auth.netlify.app/)
- [Resend Component](https://github.com/get-convex/resend)
- [Convex Test](https://www.npmjs.com/package/convex-test)
- [React Hooks](https://docs.convex.dev/client/react)

---

**This guide is tailored specifically for finlit.gg's architecture and requirements. Refer back to this document when implementing backend features to ensure consistency and best practices.**

