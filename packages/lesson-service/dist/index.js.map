{"version":3,"sources":["../src/timeline.ts","../src/inventory.ts"],"sourcesContent":["import type { LessonDocument, LessonSegment, SegmentTimeline } from '@monte/types';\n\nconst createEmptyTimeline = (): SegmentTimeline => ({\n  version: 1,\n  steps: [],\n});\n\nconst normalizeTimelineSteps = (timeline: SegmentTimeline | undefined): SegmentTimeline['steps'] =>\n  (timeline?.steps ?? []).map((step) => ({\n    ...step,\n    keyframes: step.keyframes ?? [],\n    interactions: step.interactions ?? [],\n  }));\n\nexport const normalizeSegmentTimeline = <T extends LessonSegment>(segment: T): T => {\n  const timeline = segment.timeline ?? createEmptyTimeline();\n  return {\n    ...segment,\n    timeline: {\n      version: timeline.version ?? 1,\n      label: timeline.label,\n      metadata: timeline.metadata,\n      steps: normalizeTimelineSteps(timeline),\n    },\n  };\n};\n\nexport const normalizeLessonDocumentTimelines = <T extends LessonDocument>(document: T): T => {\n  document.lesson.segments = document.lesson.segments.map((segment) => normalizeSegmentTimeline(segment));\n  return document;\n};\n","import type {\n  LessonDocument,\n  LessonMaterialInventory,\n  MaterialBankDefinition,\n} from '@monte/types';\n\nexport interface InventoryDelta {\n  tokenTypeId: string;\n  delta: number;\n  reason: 'consume' | 'replenish' | 'reset';\n  bankId?: string;\n  segmentId?: string;\n}\n\ninterface BankRuntimeState {\n  available: Record<string, number>;\n  initial: Record<string, number>;\n}\n\nexport type RuntimeInventoryState = {\n  banks: Record<string, BankRuntimeState>;\n};\n\nexport const deriveAcceptedTokenIds = (\n  bank: MaterialBankDefinition,\n  inventory: LessonMaterialInventory,\n): string[] => {\n  if (bank.accepts.length > 0) {\n    return bank.accepts;\n  }\n  return inventory.tokenTypes.map((token) => token.id);\n};\n\nconst toRecord = (entries: Array<[string, number]>): Record<string, number> => {\n  const map: Record<string, number> = {};\n  entries.forEach(([key, value]) => {\n    map[key] = value;\n  });\n  return map;\n};\n\nconst createBankState = (\n  bank: MaterialBankDefinition,\n  inventory: LessonMaterialInventory,\n): BankRuntimeState => {\n  const tokenIds = deriveAcceptedTokenIds(bank, inventory);\n  const initialQuantity = bank.initialQuantity;\n  let initial: Record<string, number>;\n  if (typeof initialQuantity === 'number') {\n    initial = toRecord(tokenIds.map((id) => [id, initialQuantity]));\n  } else {\n    initial = { ...initialQuantity };\n  }\n\n  tokenIds.forEach((id) => {\n    if (typeof initial[id] !== 'number') {\n      initial[id] = 0;\n    }\n  });\n\n  return {\n    available: { ...initial },\n    initial,\n  };\n};\n\nexport const buildRuntimeState = (inventory: LessonMaterialInventory): RuntimeInventoryState => {\n  const banks: Record<string, BankRuntimeState> = {};\n  for (const bank of inventory.banks) {\n    banks[bank.id] = createBankState(bank, inventory);\n  }\n  return { banks };\n};\n\nconst summarizeDeltas = (deltas: InventoryDelta[]) => {\n  const summary = new Map<\n    string,\n    Map<\n      string,\n      {\n        net: number;\n        consumed: number;\n        replenished: number;\n      }\n    >\n  >();\n\n  for (const delta of deltas) {\n    if (!delta.bankId) continue;\n    if (delta.reason === 'reset') {\n      summary.delete(delta.bankId);\n      continue;\n    }\n    if (delta.tokenTypeId === '*') continue;\n    let bankSummary = summary.get(delta.bankId);\n    if (!bankSummary) {\n      bankSummary = new Map();\n      summary.set(delta.bankId, bankSummary);\n    }\n    const entry =\n      bankSummary.get(delta.tokenTypeId) ?? {\n        net: 0,\n        consumed: 0,\n        replenished: 0,\n      };\n    entry.net += delta.delta;\n    if (delta.reason === 'consume') {\n      entry.consumed += Math.abs(delta.delta);\n    } else if (delta.reason === 'replenish') {\n      entry.replenished += Math.abs(delta.delta);\n    }\n    bankSummary.set(delta.tokenTypeId, entry);\n  }\n\n  return summary;\n};\n\nexport type ConsistencyIssue = {\n  bankId: string;\n  tokenTypeId: string;\n  expected: number;\n  actual: number;\n};\n\nexport const detectInventoryConsistencyIssues = (\n  inventory: LessonMaterialInventory,\n  runtime: RuntimeInventoryState,\n  deltas: InventoryDelta[],\n): ConsistencyIssue[] => {\n  const issues: ConsistencyIssue[] = [];\n  const deltaSummary = summarizeDeltas(deltas);\n\n  for (const bank of inventory.banks) {\n    const runtimeBank = runtime.banks[bank.id];\n    if (!runtimeBank) continue;\n    const expectedTokens = new Set<string>([\n      ...Object.keys(runtimeBank.initial),\n      ...Object.keys(runtimeBank.available),\n    ]);\n    const accepted = deriveAcceptedTokenIds(bank, inventory);\n    accepted.forEach((tokenId) => expectedTokens.add(tokenId));\n\n    const bankSummary = deltaSummary.get(bank.id);\n\n    for (const tokenId of expectedTokens) {\n      const initial = runtimeBank.initial[tokenId] ?? 0;\n      const available = runtimeBank.available[tokenId] ?? 0;\n      const net = bankSummary?.get(tokenId)?.net ?? 0;\n      const expected = initial + net;\n      if (available !== expected) {\n        issues.push({\n          bankId: bank.id,\n          tokenTypeId: tokenId,\n          expected,\n          actual: available,\n        });\n      }\n    }\n  }\n\n  return issues;\n};\n\nexport const assertInventoryConsistency = (draft: LessonDocument) => {\n  const inventory = draft.lesson.materialInventory;\n  if (!inventory) return;\n  const tokenTypeIds = new Set(inventory.tokenTypes.map((token) => token.id));\n  const segmentIds = new Set(draft.lesson.segments.map((segment) => segment.id));\n\n  for (const bank of inventory.banks) {\n    const acceptedIds = bank.accepts.length > 0 ? bank.accepts : Array.from(tokenTypeIds);\n    for (const tokenId of acceptedIds) {\n      if (!tokenTypeIds.has(tokenId)) {\n        throw new Error(`Bank ${bank.id} references unknown token type ${tokenId}`);\n      }\n    }\n    if (bank.scope === 'segment') {\n      if (!bank.segmentId || !segmentIds.has(bank.segmentId)) {\n        throw new Error(`Bank ${bank.id} references unknown segment ${bank.segmentId ?? '(missing)'}`);\n      }\n    }\n  }\n\n  const bankIds = new Set(inventory.banks.map((bank) => bank.id));\n  for (const segment of draft.lesson.segments) {\n    if (segment.materialBankId && !bankIds.has(segment.materialBankId)) {\n      throw new Error(`Segment ${segment.id} references missing bank ${segment.materialBankId}`);\n    }\n  }\n};\n"],"mappings":"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","names":[]}